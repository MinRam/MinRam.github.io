{"pages":[{"title":"404","text":"","link":"/404/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"comments","text":"","link":"/comments/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"radar","text":"","link":"/radar/index.html"}],"posts":[{"title":"程序员面试攻略 —— 简历","text":"一、前言 Overview在我的职业生涯中，至今为止应聘过3家公司。其中对于我来说，最难的不是现在的Offer，而是本科毕业出来时候，第一次找到的工作。 在那时候，我经常吐槽学校的培养计划，在大学四年中，仅存的软技能课只有职业生涯规划，而里面的知识又和实际职场严重脱轨。这么重要的知识，却没法在大学时期能够很好的重视和培养，最后在毕业季进行磕磕碰碰地就业，也浪费了自己应届生的优势。 在我进入工作之后，渐渐明白： 程序员，永远不只是代码。这个岗位，他首先是一个职业，包含了应聘，沟通，领导等能力；接着是一名IT技术员工，拥有擅长领域的IT技术；其次是一名工程师，赋予工程学技能框架。最终才实现技能变现。 我非常感谢陈皓哥给予的宝贵经验，让自己能够跟随着他的脚步，在毕业前能提交出一份堪堪及格的答卷。也在之后的职业道路上，一直能有一盏明灯引领着自己，去进步，去发展。 二、简历的基本要素 Basic简历，基本上来说，应该简要明了，筛选能有利于自己应聘岗位的信息，不能单纯罗列，要突出自己的技能和长处，给予招聘方想要的信息。 通常来说简历，包括以下几个部分： 2.1 个人信息 自我介绍 这个自我简介是用最简单的话来说明自己的情况，不超过 200 字，自述不超过5分钟。 比如：10+ 年的软件开发经验（说明你的主业），4+ 年的团队 leader 经验（说明你的领导力），擅长高可用高性能的分布式架构（说明你的专业和专攻），多年互联网和金融行业背景（说明你的行业背景），任职于 XXX 公司的 XX 职位（说明你的职业），负责 XXX 平台或系统（说明你的业务场景）··· 基本信息 包括姓名，年龄，性别，联系方式（电话 + 邮箱)， 个人证件照 其中姓名在面对国际公司（主要指大厂）可以带上英文名；联系电话可以加上国区号（如+86）；邮箱建议选择更具职场性质的邮箱（如Gmail,hotmail)，少用QQ邮箱，国企类型的可以选择网易邮箱等；个人证件照意义不大，可以不加，毕竟不看脸； 个人网站 主要指个人主页、博客、GitHub 或是 Stack Overflow等平台，是很好的作品展示方式 如果有自己的独立域名，很建议附在你的简历，这就是你动手能力的加分项。同时对于前端领域，自己设计的博客，就是一个很好的招牌和审美品味的展示。但应注意自己博客中的内容，反应自己的思考深度，对技术原理性的刨根问底，对技术的偏执和看法。 个人技能 罗列几条个人技能，快速阐明已掌握的技术和领域。不应太多，点睛即可。 如果是从招聘简章上面试的，上面的要求，就是你该选择突出什么技能的纲要。 – 技术领域 —— 前端，算法，AI，分布式，系统底层，DBA等 – 业务领域 —— 行业领域（金融，通信，电商，政务等）&amp; 业务领域（支付，CRM，物流等） – 技术领域 —— 表明自己专精的编程语言，编程框架，常用软件/工具，设计或架构 – 经验和软技能 —— 主要指领导力，执行力，项目管理能力，设计能力。 工作经历和教育经历 工作经历和教育经历都应服务于证实和描述个人技能的高度 根据项目的含金量和同竞聘岗位的关联性，从大到小列出自己的工作经历和项目，应突出项目的含金量（难度，规模，挑战，自己的职责和输出，以及他人的认可）， 个人建议参照STAR法则，梳理自己的项目。 三、简历模板 Template简历，应突出简介明了。几点琐碎要求： 简历的内容应简短精确，控制在两页内； 简历格式在提交时，应为PDF格式，保证格式不会混乱； 面对国际企业或有英文工作环境的企业，应附带英文版简历，处理好里面的描述和基本语法（这将体现你的英语功底）； 简历的模板，可以参照Office上关于简历的模板，主要以简约风格为佳； 简历中的罗列多点的地方应控制2-3个，不应过多； 自我评价模块，内容虚浮，个人并不建议添加。对于大部分公司，并不在意你的自我评价，他们更相信自己看到的和考验出来的； 四、知识储备 Knowledge 以上提到的内容，应严格按照自己的情况如实填写。 有人提过面试会问什么内容？其实简历就是面试官问你的一亩三分地。你写什么，面试官就会问你什么。对于大厂和行业前端的公司，就不要打肿脸充胖子，是什么就是什么。面试官在面试时会不断试探我们知识领域的广度和深度。 你写上了 Java，那么 Java 的基本语法都要了解，并发编程、NIO、JVM 等，你多少要有点儿了解，Spring、Netty 这些框架也要了解。 你写上了 Go，那么至少得把官网上的 Effective Go 给看了。 你写上了 Redis，那么除了 Redis 的数据结构，Redis 的性能优化、高可用配置、分布式锁什么的，你多少也要把官网上的那几篇文章读一读。 你写上了面向对象，那么怎么着也得把《设计模式》中的 23 个模式了解一下。 你写上了分布式架构，那么 CAP 理论、微服务架构、弹力设计、Spring Cloud、Cloud Native 这些架构就要做到心里有数。 你写上网络编程，那么 TCP/IP 的三次握手，四次挥手，两端的状态变化你得知道吧，Socket 编程的那几个系统调用，还有 select、poll、epoll 这些异步 IO 多路复用的东西，你得知道。 对于关键技术，你至少要有八成功力，以及一定的深度原理学习。 对于算法知识，刷题就完事，👉点我👈 对于系统设计，一般只有在社招面试才会提到，可以参考我《简单系统设计》 五、经典问题 (拓展) Question面试中总有几个经典问题，往往需要提前准备： 说一个你做过的最自豪的项目，或是最近做过的一个项目。 了解候选者的兴趣点，和高质量项目。 说一个你解决过的最难的技术问题，或是最有技术含量的问题。以及如何解决的 了解候选者对难题的处理能力。 说一个你最痛苦的项目，或最艰难的项目。 了解候选者的抗压能力。 说一个犯过的最大的技术错误，或是引发的技术故障。 了解候选者对错误的态度，以及是否能够自我改正或优化。 这些问题都会伴随着对各种细节的不停追问，因为这样的问题太容易造假了。所以，面试官会不停地追问细节，就像审问一样。因为一个谎言需要用更多的谎言来掩盖，如果没有经过高强度和专业的训练的话，最好不要撒谎。 对此，如果你想有一个比较好的面试回答效果，这不是你能临时准备出来的，工夫都是花在平时的。笔者的方式就是在工作中写文档 ，在工作之余写博客。能讲得清，讲得好，就能在面试中有较好的语言组织能力和工作总结能力。 六、小结 Summerize简历总的来说，就是突出面试官想要的，简历内容有限，不应长篇大论。 参考 [1] The Google Résumé: How to Prepare for a Career and Land a Job at Apple, Microsoft, Google, or any Top Tech Company","link":"/cheng-xu-yuan-mian-shi-gong-lue/interviewresume/"},{"title":"程序员面试攻略 —— 薪资构成","text":"这篇文章是自己在面试准备中，参照他人经验以及自身总结经历的随笔。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 前言开篇时候膜一下《中国人民共和国劳动法》。 吐槽下官网互联网建设不足，急需IT人才~ 一、薪水构成科技公司的小伙伴们会用 TC (Total Compensation)，来表示实际收入总包。总包的计算方法各公司稍有不同，但无外乎包括以下几个部分： 基本工资 Base (五险一金、个人收入所得税) 年终奖 Bonus 股票 Equity (RSU/Option) 初始股票 Initial grant 新发股票 Refresh 而再详细点 二、看得到的工资2.1 基础工资 Base Salary这是在入职合同上填写的固定收入，具体是根据入职时候的市场价、面试表现、职位等级决定的。入职后将随公司策略有一定的涨幅。 可以理解为，这是公司每个月给我们的月薪。在扣除五险一金，工资税后，剩下的会转账到个人工资卡上，也就是你实际到手的金额。 工资税的计算， 可以查看 中华人民共和国个人所得税法, 可以通过个人所得税APP查看， 从当地的本地宝公众号查询。回复“个税”，可以直接进入个人所得税入口。 五险一金，查看下文。 2.2 年终奖 Bonus 年终奖，是老板给予员工一年来的工作业绩奖励，一般位于年末到年初时候发放。 年终奖主要用来奖励员工一年的业绩表现， 以及摁住员工跳槽的念头。所以我们可以从一年的年终奖看出公司对你的期待。往往年终奖发完的这一阶段，是你进行离职或者跳槽的最佳时间。 年终奖上不封顶，一般为月薪的2个月。 年终奖也是同样需要缴纳个人所得税的。可以查看 《国家税务总局关于调整个人取得全年一次性奖金等计算征收个人所得税方法问题的通知》。 2.3 股票 Restricted Stock Units股票收入主要包含两部分： 初始合同一次性承诺给予股票，分四年（或五年）按月/季度/年发放 各公司政策稍有不同，有些公司在员工入职一年后才开始按季度发（业内叫 one-year cliff），而有些公司入职第一个月就开始发 不是所有公司都等额发放，比如亚麻头两年 5% 和 15%，后面两年各 40%，Snap 也有类似规定。微软，则是等额发放。 每年新发股票 Refresh 每过一年，公司会根据员工表现，新发一定股票，同样也是分四年发完 新入职第一年，不是所有公司都给 refresh，各家公司 refresh 规定都不太一样，会随着市场情况调整，具体情况具体讨论 据说，Uber 把 refresh 当成 bonus 的一部分，分 cash bonus 和 stock bonus 另外在司期间，对于上市公司，可以行使公司股票的购买权（以某个特定价格购买股票的权力） 个人觉得股票避税的两种方式： 等你老了没有这么高工资了再卖，这样capital gain tax braket 比较低（因为交易税和收入税挂钩 如果你有多支股票的话，找机会卖一个亏损的，claim capital gain loss， 然后再卖这个赚钱的，这样两两相抵。 2.4 五险一金 five-insurance payment 再膜一下 《中华人民共和国社会保险法》 五险一金是指用人单位给予劳动者的集中保障性待遇的合称，包括【五险】（养老保险、医疗保险、失业保险、工伤保险、生育保险）和【一金】（住房公积金）。 缴纳基数是社保计算的基数，决定了五险一金的缴纳金额。新入职员工是以起薪当月月收入作为缴纳基数，入职一年以上的员工以上一年月平均收入作为缴纳基数。 注意，有部分公司的社保基数并不会随着你的月薪资增涨而增涨（一个职业坑） 养老保险 (企业 + 个人共同缴纳) 是国家根据法律、法规的规定，强制建立和实施的一种社会保险制度。 在达到法定退休年龄，且累积缴纳养老保险费满15年。 由社保机构每月给你发放的养老金。取决于你交社保的年限，每月缴纳金额，户籍地，职称等决定。 医疗保险（企业 + 个人共同缴纳） 是补偿我们因为疾病造成的经济损失（医药费, 住院费等）建立的社会保险制度。主要是减轻我们的医疗费用负担，每月从我们月薪资扣除保险费用，从而可以报销部分或全部医疗费用。 医保卡， 分成统筹账号和个人账号，具体可参考当地标准。 失业保险（企业 + 个人共同缴纳） 是在我们因失业没有经济来源时候，能给我们提供基础生活保障的一种社会保险制度。 被公司辞的，并且原公司有给你按规定缴纳失业保险。（如果是被辞，按劳动法规定，还需要支付你 N+1 ~ 2N+1的工资费用） 可按月领取失业保险金（满足基本生活费用） 工伤保险（企业缴纳） 在工作或特殊情况下，因意外伤害或者患职业病导致的暂时或永久丧失劳动力和死亡时，劳动者或者遗嘱从国家和社会获得物质帮助的一种社会保障制度 简单来说，因工受伤拿补助。对于程序员，尤其注意自己在“加班期间”如果受伤，需要指明工作期间。 这是企业给员工缴纳的健康保障 生育保险（企业缴纳） 是国家通过立法，在怀孕和分娩的妇女劳动者暂时中断劳动时，由国家和社会提供医疗服务、生育津贴和产假的一种社会保险制度。 一是生育津贴（社保机构发放产假/陪产假期间的工资），二是生育医疗待遇（报销医疗费用） 休产假期间，如果有生育津贴，公司是可以不需要再发放工资（但如果生育津贴如果不足，公司需要补全到月工资水平）。 住房公积金 是国家强制用人单位和雇员按照相同的比例交的一种长期住房储蓄金，专项用于个人支付住房方面的费用。 具体用途就是， 申请贷款买房（利率低），付房租费用，支付房屋装修费，甚至治疗重大疾病。如果实在没有用处，最后满足条件可以全额现金提取。 补充个异地跳槽后，本地公积金可以进行封存，在你新入职一个月后可申请异地转移接续手续。三、看不到的工资 除了以上提到几点，刚入职是还会有一笔现金签字费，入职后一定时间内支付，主要由 negotiation（有无 competing offer、公司多么想招你）决定。 另外，还有各大科技公司著名的好福利，比如健康保险、免费的一日三餐、健身房、游泳池，博物馆免费门票/打折票，车险、房屋保险、租车、买车、滑雪等一系列的 corporate rate，免费/打折的衣服干洗、理发、体检，commuter benefit 报销上下班公共交通，等等。 例如, 微软，提供餐补，健身费用和培训费用报销，医疗保险公司全额报销，足额公积金等。如有兴趣，拿简历砸我吧！ >- 已阅留爪，分享自己公司福利制度 (ฅ´ω`ฅ) -","link":"/cheng-xu-yuan-mian-shi-gong-lue/interviewincoming/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hexo/hello-hexo/"},{"title":"程序员面试攻略 —— 薪资谈判","text":"这篇文章是自己在面试准备中，参照他人经验以及自身总结经历的随笔。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、谈工资需要谈工资，就是要钱，赤裸裸要钱，要完钱后还是要钱。整个过程需要承担一定的风险，存在谈崩的可能。 如果觉得工资是由能力决定的，公司会根据自己能力很公平的裁定的人，大可跳过这个回答。 比如我，把自己比喻成商品，信奉市场供需关系。不是公司单方面决定我的工资，定期准备面试，保证自己的市场竞争能力。 二、谈工资的人群如果你是实习生&amp;应届生，那谈工资的空间并不大，那俩都是差不多的背景，拿IT类职位，一年收入差距大概一两万。如果是经验丰富的，能通过谈薪提高几万年薪。 不过我自己还是建议尽早开始练习谈薪，毕竟这样的机会不多，为未来的自己提前练习谈薪资。薪资是一步步往上提高的，每一步都要争取最大利益化。（谈薪过程巨刺激） 三、公司方面的面试成本有个指标叫做CPH (cost per hire)，人均招聘成本。招聘一个合格工程师，需要花费多个款项，包括简历来源、招聘工具、中介代理费、候选人的差旅和住宿、招聘活动开支。 除此之外，还包括招聘团队的薪资，鼓励奖金，甚至是技术面开发人员带薪面试。（打断一个有面试能力的开发人员去组织面试，需要花费更多的时间让他回归到原来的工作上) 加上并不是每次应聘者都能符合要求，拿到offer。或者是拿到offer的应聘者，最后也有一定的概率拒绝offer。当你拿到offer时，公司已经在你身上花费了很多时间和钱。 另外负责跟你交接的HR，可以了解他们薪资体系，绩效奖金（入职率）占据他们大部分的薪水。他们具有很强的动力，撮合你和公司的缘分。（听说有的公司会选择第二个HR来谈薪，避免这种事情。） 综上，如果你通过了面试，拿到offer，公司内部所有人都希望你能接受，而不是拒签。 四、公司初步定薪套路每个职位，都有对应的级别，以及相应级别的薪资范围，同样的级别也会有高薪低薪之分。另外同样的职位，绝大部分不会给上限工资，这涉及到公司的工资预算。 HR给的offer数字，会考虑： 能低价就低价（大部分人就这样被牵着鼻子走） 会给后面的提薪留余地（如果你有讨价的话） 太低了，可能会直接被拒。 HR往往会依照明确的参考标准（比如不断询问你当前的薪资水平），再加上一定的涨幅出价。 注意，HR并不会根据你的能力出价的。能力是个不可以客观量化的东西。仅仅通过面试是很难考察出一个人的真正能力（面试表现好≠工作能力好）。 另外，你的老雇主出10万就能招到你，我司为何要出20万甚至30万？增加20%，一年给12万就很好了。还有，你为什么只值10万？是不是能力其实也就那么回事啊。尤其是好多年没跳槽的人，是不是没有能力拿高薪？这些想法未必正确，但是从公司的角度来看，有这些疑问，不算过分。 再给出几个不同角度的参考因素： 不利的一面： 应聘旺季，如春招秋招，公司有较多的候补人，此时供大于需，公司大概率不在乎你。 应届毕业生，应届毕业生的工资，一般有经验的HR都能猜到，回到明确参考标准那点。 老钉子户，由于长时间未挪窝，基本丧失市场竞争力，HR就会按市场平均水平直接给。（当然，对于资深高级人员，往往通过猎头来寻求谈判。） 进城户，之前的生活消费水平低，迁移到较好的城市，这种对于HR会给较低薪资，因为好打发。 有利的一面： 缺人的岗位&amp;技能，意味着你是个香饽饽，卖方市场，会有多家公司抬价。 海王，待过多家公司（非负面记录），工作多年，经验老道，HR猜不到你工资。 大公司背景，会给HR足够的俯视压力。 公司周边基建因素，诸如当前国内存在大公司往郊区迁移，周边配套服务往往不足。 还有其他的因素，不一一例举。以上也能作为就业参考因素。 五、谈判前的准备工作 合理安排面试时间，能保障手上有多份Offer。多份Offer在手，方便比较竞价。同时就算谈崩了，也有其他offer，能走选择的余地。如何合理安排时间，就需要考虑到公司的招聘速度。这个参考对应面经，或直接询问hr即可。 说下公司竞价的原因，之前提过，一场面试并不能衡量一个人的各方面素质，能满足职位要求。每家公司都出现过，招聘后不能给出有效产能的员工，最后只能开除或者内部调岗。 然而，如果你拿到了多家公司的Offer，得到多家公司的认可，这就是一个很强的信号。经过了多轮面试的考研，大家都认可。公司非常愿意高价招手握一把Offer、大家都说好的求职者。 不透露当前工资水平。对这个就是，不说，不谈，不填。 大部分公司是不能看到前东家薪资的。（进去背调后才会要求工资流水）没必要说，也没必要虚报，不说就行。工资是根据当前的背景和经验决定的，选择了寻找新公司，就说明当前薪资是不满足自己的价值的。那新公司又有啥理由，以此为借口继续打压？ 六、谈判Tips在公司已经给出具体工资数字情况下，如何继续讨价还价 双方保持兴趣是前提 如果你没兴趣加入这家公司，甚至对公司的前景不看好。那就算你再牛叉，对公司来说，招聘你并不会带来任何收益。公司会果断取消Offer。你需要对公司有强烈的兴趣，这样公司才会反过来“追”你，甚至愿意让步加价。即使后面双方意见不一致，也不至于留有坏印象。 对于一家公司，去什么样的小组，公司环境和发展机会，甚至公司的未来计划如何，都是选择Offer的重要因素。入职前，能从不同角度去看待公司，从不同的渠道收集信息，能提前预防你踩坑。 公司文化，可以参照各种新闻对公司的介绍。公司在意什么，领导强调什么，那就是他们的公司文化。说“好”就完事。 沉住气，不要当场答应 无论对方给出什么样的总包，即便是惊喜，即便是大牛公司，即便是你现在唯一的Offer，也不要立马答应，因为任何时候都是有讨价还价的地步。HR并不期望当场拿到答复，他们告诉你的同时也做好了收到拒Offer的消息。 对于HR，为了能促使你接受Offer，HR甚至会主动加价，沉住气没准你每年能拿到更多的钱。 多听少说 当你拿到Offer，进入了谈薪资的阶段时候，注意要多听少说。 HR行业门槛普遍较低，可以发现很多是文科出身，毕业没多久的妹子，当然这不包括经验老练的猎头。沟通，是一件细活，你需要留意她们说的每一句话，每一个字，也许她们无意之间会透露很多信息给你。沉默是金，让对方多揣测你的心思，出昏招。我们需要足够的信息来支撑我们接下来的谈判。 比如： 谈到薪资的时候，你沉默不语，她可能回了一句，“你对股票还满意么？”，你可以从中得出股票部分还有提升空间。 谈到部门招聘计划，HR答复有很大的招聘计划，你可以从中得出公司迫切填补当前的人力需求。综上这些，我们在接下来的谈判都会更有底气 书面确定工资数目 大部分的公司，会随着Offer会发一个正式的邮件通知。而有的公司，只会电话口头Offer。口头Offer，意味着缺少法律效应，即便入职后公司基于的薪资不一致，你也无从谈起。 为了防止公司“理解有误”，也为了防止公司“将来反悔”，我们还是要想方设法在入职前，拿到这份正式的Offer邮件。或者自己主动发送这封邮件，如果对方答复了，也是具有法律效应的。 关于程序员薪资组成，我会在后续出单篇描述。 按照自己的节奏进行 仅限于跳槽的同学们。对于第一份offer，自身还是比较被动的，只能适应他们的节奏。 HR往往乐意逼着我们接Offer，比如两天内给答复。对于这种，只有两个字，没门！至于拒绝的理由也是显而易见的，拖家带口、外地搬家（卖房子，子女上学，配偶工作等）、多份Offer(综合考虑) 牢记一个原则： 我们值得这个价，而且现在我们是在选择更好的机会,而不只是为了饭碗。公司如果想招揽我们，就需要拿出足够的诚意。 催其他公司给offer 谈判最有力的手段，就是多家公司竞价。 在收到A公司的Offer后，转头找B要Offer，催着他们，千万不要等着他们答复。如果A公司的Offer有分量，你可以跟B公司摆摆。在过程中，会有HR让你透露下其他Offer的薪资，你只要牢记对每家公司都透露，自己强烈的兴趣，再拿其他更高的Offer比较。没准公司就咬咬牙加价了。 整个过程，就跟菜市场讲价一样，如果你精通此道，那必定手到擒来。中间有很多细节需要自己慎重处理，但一定要内心强大，坚持下来，没准接下来你能谈出一辆奔驰🚗（就只动动嘴）。 七、offer的选择 Offer的选择，需要结合自己的情况思考。这里只是我个人的遇到的一些情况。 薪资， 薪资一般包括：基础工资（Base Salary)、奖金（Bonus)和期权（Stock）。 可以找个在线薪资计算器，大概计算每年的收益多少。以及包括税前税后的收入是否满足自己的期望。 五险一金， 国内和国外企业在这一方面的待遇相差较多，特别是住房公积金这一条。主要作为国内和国外企业Offer的考虑点。 上市公司， 相比没上市公司，存在很大的不确定性。如股票的估值，上市6个月后才能套现股票，以及公司的发展前景。当然，也存在等公司上市后，股票套现，实现财务自由。这点回到之前自己对公司的了解和发展的预判。 另外，假若如果只是考虑跳板因素，则更多的是考虑职位和领域，能给下一次提供更好的经验。 职位， 职位涉及的领域，决定了你下一份工作的方向和范围。选择的这段经历，将作为转行管理的跳板，未来高升的积累。这里建议多考虑长远目标。 凡是没有立即兑现的，都是虚无的，就当没有给。 画饼永远都是老板的手段，如果兑现了，得偿所愿。那没有兑现呢？你就真白打工了。 八、最后薅一把 无论对方给你什么数字，就算满足你的期望，也不建议你当场答应。玩的就是心理战，没准最后关头，公司给你加个红包，比如签字费涨几万等等。 >—— 码字不易，已阅留爪 (ฅ´ω`ฅ) ——","link":"/cheng-xu-yuan-mian-shi-gong-lue/interviewsalary/"},{"title":"简单系统设计 —— 负载均衡（二）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 负载均衡, 指将流量分配到多个服务器，以确保流量能到合适的服务器进行处理。 负载均衡（Load Balance) 是分布式集群中的核心组件。分配流量到后端集群上的多个服务器中，主要目的是： 分摊： 将流量压力分摊到后端集群中的所有节点，这也是无状态水平扩容的基础要求之一。 可用： 将流量分配到可用的后端节点中，以保证对于前端使用者来说，服务一直是可用的。 安全: 能有效的分流压力攻击的流量，如DDOS. 环境隔离： 诸如协议转换（SSL流量的加解密）等一系列预处理，都会放在负载均衡上。 扩展概念：网关 Gateway, 架构上的概念，除了负载均衡外，直接分割了内部应用和外部服务，实现安全层的认证功能。解决服务治理的问题，将服务聚合的逻辑下沉到服务层。 二、在系统中的位置 Position在商用级系统中，负载均衡常放在以下三种会面对较大流量的位置： 终端（PC, 移动设备， 物联网设备) 和 Web服务器集群 Web服务器集群 和 内部服务集群（业务服务，缓存服务等） 数据库 和 数据库操作的服务 可以看出每个集群前，理论上都可以放入负载均衡作为入口和出口。需要权衡成本，维护等因素，最终决定是否需要。 三、优势 Benefits 用户体验优化： 用户体验不间断，更快速的服务。用户并不需要等待故障节点的修复。 单点故障隔离： 隔离单点故障对整个系统的影响，从而提供额外修复迭代的时间。 可用时间增加： 减少系统的停机时间，可以做到不停机的组件维护，版本升级（滚动升级，灰度发布）。 流量统计： 通过在负载均衡器部署额外的预处理组件，可以构建流量模型，为后续性能提升和业务优化，提供数据参考。 自动化入口： 对于商业级系统开发团队，自动化是解放团队人力的关键措施。作为流量必经站，负载均衡器是自动化运维的重要切入点。 网络管家： 允许系统组件灵活的网络，在不影响安全性，服务或性能的情况下能挑战更复杂的业务场景。实现软件定义网络。 四、转发策略 Algorithms 负载均衡是如何选择要发给哪台后端节点？ 对于负载均衡器，有两个重要的因素： 要发给谁 &amp; 能发给谁。前者是能处理流量的节点集合，后者是状态为健康的节点集合，两者的交集就是目标节点集合。那么剩下的就是以什么样的算法去将压力分布到目标节点集合上。 健康检查，是负载均衡器判断节点为健康的逻辑。基本思路：负载均衡器定期向后端节点发送健康检查请求，通过判断返回值来决定该节点是否为健康。如未收到返回值或者收到的返回内容中说明该节点无法接受流量，则负载均衡器将会把这个节点从目标节点集合移除，直到下一次检查或者节点主动告知。 面对不同场景，选择对应的转发策略： 最少连接 Least Connection Method 将流量转发给有效连接最少的服务器。适用于流量中有大量持久连接。 最短响应时间 Least Response Time Method 将流量转发给有效连接最少且平均响应时间最短的后端节点。 最少带宽 Least Bandwidth Method 将流量转发到处理流量最少的后端节点上。适用于大流量的业务场景。 轮询调度 Round Robin Method 将可用后端节点组成环状队列，依次转发给该队列。适用于持久连接较少且后端节点处理流量的能力一致的场景。 加权轮询调度 Weighted Round Robin Method 现实场景中，每个后端节点随着伸缩，处理流量的能力各不相同。因而加了一个参考的权值。权值高的后端节点，会比其他后端节点更早和更多地获取到流量。 IP哈希分散 IP Hash 通过客户端的IP地址决定哪个后端节点接受请求。 五、自身可用性单个负载均衡器仍存在故障的概率，因而可以设置冗余负载均衡器，构成主备HA或者集群形式。互相监听对方的健康状态。在主机故障的场景下，备用机能主动接管流量。 六、负载均衡的类型（加深内容） 在七层开放系系统互连模型（OSI)中， 网络防火墙 位于1-3层（L1-物理连线，L2-数据链路，L3-网络层）。而负载均衡器,则在4-7层（L4-传输层，L5-会话层, L6-表示层，L7-应用层)。 L4 根据来自网络和传输层协议的数据（IP地址和端口）完成转发 L7 读取数据包内容，可以根据HTTP Header，Uniform resource identifer，HTML form data和SSL Session ID的内容决定转发逻辑。 根据负载均衡的协议逻辑，主要分为一下几种类型： 6.1 SDN使用SDN（软件定义网络）的负载平衡将控制平面与数据平面分离以进行应用交付。这允许控制多个负载平衡。 该类型的负载均衡器，笔者也是一知半解，目前只看到相关的学术论文，待后续补充。 6.2 UDP针对UDP协议进行转发的负载均衡器，仅保留基础的纠错，追求极致的性能&amp;延迟。特别适用于游戏和直播的产品中。 6.3 TCP常见的业务负载均衡器基本是采用TCP协议。大部分的软件系统还是提供数据处理服务，光丢包就会丢失重要的数据。需要基于TCP协议保障数据包准确无误地到达目的地。 6.4 SLB服务器负载均衡器，针对后端节点为服务器的使用场景，将客户端流量分配到服务器上，以确保一致的高性能业务交付。 6.5 Virutal虚拟化负载均衡器，指负载均衡器的承载体是虚拟化设备（如虚拟机）。常见于正在尝试云化的产品。仍存在传统硬件的限制（维护，停机，可扩展性） 6.6 Elastic弹性负载均衡器，在需要的时候拓展自身实例，以满足业务需求。如流量增大，或者后端节点增加，需要提升负载均衡器的流量处理能力和后端节点的管理能力。 6.7 Geographic地理负载均衡器，可以根据需要将流量转发到指定地理位置的后端节点，或次级负载均衡器。在全球级商业系统，往往会有一个全球负载均衡器，来处理来自世界各地的流量，再交给离流量发送者较近的次级负载均衡器，以减少延迟。、 6.8 Multi-site多站点负载均衡器，用来在多个站点间分配流量。如上一点提到全球负载均衡器。常见使用场景，如在生产和容灾站点间分配流量，以保证整个系统的可用性。 6.9 LBaaS在云时代，负载均衡器被抽象成一种云服务类型。不再局限于某个服务器上，能更好地配合云计算的使用场景。大部分是指基于OpenStack虚拟架构的负载均衡器。 除了从功能的分类，负载均衡器还有硬件和软件的区分。 >- 已阅留爪 (ฅ´ω`ฅ) - 下一章 《缓存》-","link":"/xi-tong-she-ji/systemdesign-02-load-balance/"},{"title":"简单系统设计 —— 分布式系统（一）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 系统设计(System Design), 即针对系统的应用需求，设计出具有高性能，高拓展性，高可用性等的系统。 每个人学系统设计的目的不一样。笔者的学习目的只有两个： 社招面试准备。为通过微软面试的系统设计阶段做准备。 脱离底层工作内容（摆脱程序猿的帽子），挺进更具有技术价值的工作领域做准备。 实际工作中绝大多数内容都完全用不到算法，更多是增删查改(CRUD)、对接 API、调整数据格式之类的。更进一步的工作，通常也是和系统设计关系更大。 系统设计面试方面的准备资料，将在《程序员面试攻略》篇补充。 接下来，介绍些现系统中常见的核心模块。 个人对系统设计的理解，也只是冰山一角，并非立山顶，也只是站于山前，从前人留下的斑斑点点揣测大山全貌，其中个人猜想成分偏多，还望各位大师指点迷津。 二、分布式系统 Distubed Systems 分布式系统，即使用廉价、普通的机器集群，去完成单个机器无法完成的计算和存储任务。其根本目标就是利用更多的机器，处理更多的数据。 比如Google，Microsoft等大型系统，其背后都是由上万台设备组成的数据中心，但对于我们，只感知到他是一个系统。 从特征开始了解： 1.可伸缩性 Scalability可伸缩性是指当系统的任务（work）增加的时候，通过增加资源来应对任务增长的能力。可扩展性是任何分布式系统必备的特性。 举个例子，跑个算法程序，耗时很久。这时候我们有两种方式可以优化： 把原来的电脑换成性能更好的电脑。 ( 垂直扩容 Vertical Scaling) 把程序分成两半，分布在两个电脑上分别承担。 (水平扩展 Horizontal Scaling) 扩展性的目标是使得系统中的节点都在一个较为稳定的负载下工作，这就是负载均衡，当然，在动态增加节点的时候，需要进行任务（可能是计算，可能是数据存储）的迁移，以达到动态均衡。 其中 MongoDB 和 Apache Cassandra 就是典型水平扩容的分布式系统，可以通过增加机器节点，来提升对数据读写的处理能力。而MySQL则是垂直扩容的分布系统，提供了简单的途径用以切换到性能更好或者成本更廉价机器上，但这需要一定的停机时间（DownTime)。 伸缩不仅仅在资源的扩展，也包括在空闲时期对系统的缩容，来节省不必要的资源成本。特别是云时代，算力决定了产品的硬件成本, 淘宝不可能以双十一的处理成本来处理每日的订单。 2.可靠性 Reliability可靠性关注于系统发生故障(功能故障）的概率。例如当系统中有节点故障时，能被其他健康的节点替代（例如HA, 容灾等），那么可以认为在整体功能上有较高的可靠性。 以淘宝为例，当用户添加一个商品到购物车时候，系统应不丢失这个操作。即使负责处理这个操作的服务器死机，将由另一台服务器快速替代他处理这个操作。 显然冗余是保障系统的一个重要措施。这也同样带来了额外的成本，但对于宝贵的数据丢失，这点不足为道。 3.可用性 Available可用性关注于系统的所有生命周期里，提供服务的时间比例。 以飞机为例，一个月不间断飞行，那这架飞机的可用性较高。但如果停机维护，那就是不可用。 这里容易把可靠性和可用性的概念混淆： 可用性 被定义为系统的一个属性，它说明系统已准备好，马上就可以使用。换句话说，高度可用的系统在任何给定的时刻都能及时地工作。 可靠性 是指系统可以无故障地持续运行，是一个持续的状态。与可用性相反，可靠性是根据时间段而不是任何时刻来进行定义的。 如果系统在每小时崩溃1ms，那么它的可用性就超过99.9999%，但是它还是高度不可靠。与之类似，如果一个系统从来不崩溃，但是每年要停机两星期，那么它是高度可靠的，但是可用性只有96%。 补充： 平均故障间隔时间（MTBF，Mean Time Between Failure），是指相邻两次故障之间的平均工作&gt;时间，是衡量一个产品的可靠性指标。 平均修复时间（MTTR，Mean Time To Repair），是描述产品由故障状态转为工作状态时修理时间的平均值。在工程学中，MTTR是衡量产品维修性的值.在维护合约里很常见，并以之作为服务收费的准则。$$ Availability = \\frac{MTBF}{MTBF + MTTR} $$ 4.高吞吐 Effective 一个系统的高吞吐，指的是处理业务请求的效率，体现在两个方面： 响应时间 &amp; 吞吐量 响应时间，系统响应一个请求或输入需要花费的时间。 响应时间直接影响到用户体验，对于时延敏感的业务非常重要。 吞吐量，系统在一定时间内可以处理的任务数。这个指标可以非常直接地体现一个系统的性能，就好比在客户非常多的情况下，要评判一个银行柜台职员的办事效率，你可以统计一下他在 1 个小时内接待了多少客户。常见的吞吐量指标有 QPS（Queries Per Second）、TPS（Transactions Per Second）和 BPS（Bits Per Second）。 一个大型系统的操作业务是复杂繁琐的。以上两个指标只是粗略地估计系统的效率。除此之外，还有网络拓扑结构，网络负载和变化，涉及硬件还要考虑IO的读写等，要对一个大型系统建立性能模型，这依赖于对各方面性能指标的采集。 5.服务性 &amp; 可管理性 Serviceability or Manageability 该点考虑的是系统运行中，必经的修理和维护周期。 设计分布式系统时的一个重要考虑事项是操作和维护的容易程度。这决定了系统能保持可用时间的长短。 可管理，指在系统进行维护或者修复的简易程度和耗时长短。（如果系统不容易修复，那可以理解为系统将较长时间处于不可用状态） 考虑这点特性，需要关注与系统发生问题时： 能轻易找到问题根因， 快速提出问题修复方案 更新版本或者修复问题所需要的成本（停机？人力？物力？） 系统的操作所需要的技能程度 可管理性的考虑需要涉及到系统的整个生命周期（发布，更新等）。 题外话，服务性&amp;可管理性，在现在的大型系统中更侧重于运维的能力和成本。因此就有了Google提出的SRE团队的出现，专门针对整个系统的管理能力开发一系列监听和处理的模块。用来预测，监听和无人工干预的修复各种问题风险。在当下也有部分公司开始启动了更加创新的AIOps计划，结合智能领域，实现系统的智能管理。 综上的特征，最后根据自己产品特性需求，如搭积木般选择各式各样的组件，形成了如下的分布式系统（图中为典型组件，并非最佳组件选择）： >- 已阅留爪 (ฅ´ω`ฅ) - 下一章 《负载均衡的网关》-","link":"/xi-tong-she-ji/systemdesign-01-distubed-system/"},{"title":"瞎折腾系列 —— NPM技术雷达构建 （一）","text":"最近在梳理自己的技术栈内容，寻找一个比较清爽好看的形式来呈现和管理正好发现Thoughtworks的技术雷达，简洁，漂亮。那么把这个雷达搞成NPM包，移植入博客中，就是我的目的了。综上，开干😎。那么开始记录自己折腾路程。","link":"/xia-zhe-teng-xi-lie/programming-npm-technologyradar-01/"},{"title":"简单系统设计 —— 索引（五）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 当数据量达到一定的规模，数据库的查询性能会明显下降。这时候就是索引的出场。 数据库索引 Index就是为了提高数据库访问数据的速度（即查询的速度 Select/Update/Delete）。它的实现原理在主流数据库中时平衡树（Balance Tree &amp; B+ Tree)。也有部分数据库采用的是哈希桶的结构。 通过记录关键属性的值，在符合条件的查询操作时，就不再需要进行数据库的全表扫描，只需要扫描较少的索引页和数据页。 二、例子 Example 图书馆，一直都是关系数据库的好例子。（😗我绝不是偷懒不去想） 图书馆中收藏书籍的清单，可以看作是数据库的一张表，通常包含了这几个属性：书名，作者，刊号，主题和出版日期。通常在图书馆，有几种经常用到的查询方式：书名检索，作者检索和刊号检索。这样我们就可以通过，书名，作者或者刊号，来轻易查询到一本书或一系列书。 这里的书名，作者和刊号就像图书馆的索引。它们提供一个清晰的数据列表，便于检索。所以索引其实可以理解为一个目录，指向了数据的实际位置。当我们创建索引的时候，我们会存储该列的值，以及指向实际行数据的指针。 可以发现，索引往往是我们经常检索用到的列属性。 我们把经常操作的数据成为有效负载。 对于TB大小级别的数据库，并不是所有数据都是活跃的，例如我们只会在被查水表了，才会去翻看n天前的聊天记录。因而数据库中有效负载数据，往往是索引的第一选择。 三、代价 Cost 既然索引这么好用，那为啥不暴力把表的所有列全建成索引？ 如果把整个表都建成索引，那就跟全表扫描一样的结果了（和二叉树退化成链表同理）。同时，索引的存在会显著加快数据检索，也会减少数据的更新操作（Insert/Update)。具体在于，我们插入一条新数据时，需要更新索引。我们更新到索引关键属性的值时，也同样需要索引。 因此，我们应避免不必要的索引，并即使删除无效的索引。 索引终究只是用于数据的检索动作。如果有个数据库，经常写入数据，但检索的动作占很小的比例，那就没必要再添加索引了。真没必要脱裤子放屁👻 四、类型 Type （拓展知识）索引的类型分为一下几种： 4.1 聚合索引 聚合索引 又叫为主键索引，值得就是一张表中的唯一主键。 在现有数据库中，如果建表不指定主键，数据库会拒绝创建表的动作。实际上，一个表如果没有主键，那么他就只能被无序存放，行之间无任何关联，在通过主键检索时，也只能遍历整表。相反的，当我们指定主键后，整个表就变成了索引，从一行行数据，变成了平衡树的结构。（这里不拓展平衡树原理） 1SELECT * FROM student WHERE student_id = 88888; 每个表只有一个聚合索引。聚合索引是通往实际数据的唯一路径。 4.2 非聚合索引 非聚合索引，就是给非主键的属性，加上索引。 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 12KEY 'idx_name' ('name')SELECT * FROM student WHERE name = 'MinRam'; 每创建新的索引，该字段的数据会被单独拷贝出来。即给表添加索引，会导致表的大小增加，占用存储空间。 非聚合索引是先通过索引查到主键，再通过主键查到数据。 4.3 联合索引 联合索引， 就是将多个字段联合在一起，构成一个索引。 联合索引，一个重要的用处就是避免回表，其中回表指使用非聚簇索引进行查找数据时，需要根据主键值去聚簇索引中再查找一遍完整的记录。 12KEY 'idx_name_sex' ('name', 'sex')SELECT student_id, name, sex FROM student WHERE name = 'MinRam' AND sex = 'male'; >- 已阅留爪 (ฅ´ω`ฅ) - 下一章 《代理》-","link":"/xi-tong-she-ji/systemdesign-05-index/"},{"title":"简单系统设计 —— 代理（六）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 前面提过负载均衡, 会将前端的流量按规则分发给后端服务集群，以此来分摊压力。而代理就是其中的一个能力。 代理服务器，是客户端和后端服务器的中间服务器。特别是WEB类型的后端服务器。客户端通过连接代理服务器，请求对应的资源（HTML,CSS,Connect等）服务。它可以是软件形式（如Nginx)又或者是硬件形式(因价格昂贵，比较罕见)。 简单讲，代理就是我们不直接去做一件事而是让另外一个人代替我们去做一件事。通常，代理用于过滤请求、记录请求，或者有时转换请求（通过添加/删除头、加密/解密或压缩资源）。 除此之外，代理还能做到： 缓存网页，来提高响应性能 负载均衡 作为一个前端，控制和保护某个服务的网络请求 隐藏用户身份（如VPN😗） 负载均衡器 和 代理服务器 在整体系统中的位置一致，往往整合成网关模块。前者侧重于分摊压力，后者侧重于屏蔽客户端对服务的感知。可以理解为，负载均衡是依靠代理实现的。 二、类型 Types代理层，主体是放在客户端和业务服务器之间，所以它可以在客户端上，也可以在业务服务前新增服务器等。而常见的几种类型： 1. 正向代理 Foward Proxy大多时候说的代理服务器，指的是正向代理。一个面向内网的代理其中客户的客户端或组提供服务。通常，这些客户端是内网的一部分。 以www.example.com的服务器为例，从客户端发起请求开始： 内网客户端尝试连接到代理服务器，请求访问www.example.com; 请求通过内网到达代理服务器; 代理服务器根据之前设置的策略，选择通过，或者拒绝; 允许: 将请求转发到对应的Web服务器，将结果返回给代理服务器，再响应之前的请求。 拒绝: 根据策略返回响应内容； 正向代理是权限和控制的关键点，并且容易插入访问安全策略。 企业、组织、学校使用正向代理，以屏蔽内网中的客户端访问Internet的重要内容。主要考虑的过滤方式：例如URL，DNS黑名单，URL正则表达式过滤，MIME过滤或内容关键字过滤。 内网中的缓存服务器。如果一个资源被下载了很多次，那么代理可以将内容缓存在服务器上，这样下次另一个客户端下载相同的内容时，代理会将之前存储在服务器上的内容发送给客户端。 一些常见的正向代理软件（基于服务器的）： Cgi-Proxy Glype Squid …只要理解组件的使用场景和实现原理，就能快速了解该类型的软件。在大厂中往往有自己一套的代理软件。 2. 反向代理 Reverse Proxy 反向代理的作用与正向代理的作用完全相反。针对客户端的正向代理代理，针对服务器的反向代理代理。 反向代理通常是一个面向系统内部的代理，作用在请求流的前端来控制和保护对系统内部网络上服务器的访问。 来自 Internet 并以系统为目的地的所有流量都将通过代理服务器。在客户端看来，系统只是一个门。反向代理服务器代替其后端服务器，接受来自外部客户端的请求，并将请求转发到一台或多台后端服务器以处理请求。客户端接收到来自代理服务器的响应中，并不会有任何原始服务器的信息。 以www.example.com的服务器为例，从客户端发起请求开始： 客户端向系统发起请求； 请求通过Internet到达代理服务器; 代理服务器根据之前设置的策略，选择通过，或者拒绝; 允许: 将请求转发到对应的Web服务器，将结果返回给代理服务器，再响应之前的请求。 拒绝: 根据策略返回响应内容； 正向代理隐藏客户端的身份，而反向代理隐藏服务器的身份。 反向代理用于以下目的： SSL加速：创建安全网站时（如协议为https)，安全套接字层 (SSL) 加密通常不是由 Web 服务器本身完成，而是由配备 SSL 加速硬件的反向代理完成。反向代理为任意数量的主机提供 SSL 加密，无需为每个主机提供单独的 SSL 服务器证书； 负载平衡： 反向代理可以将负载分配到多个后端服务器； 缓存静态内容：反向代理可以通过缓存静态内容（如图片，静态HTML等）来分担Web服务器的压力。详见缓存篇 压缩：代理服务器可以优化和压缩内容以加快加载时间。 安全性：代理服务器是额外的防御层，可以防止某些操作系统和 Web服务器特定的攻击 常见的HTTP反向代理软件（服务端）： Apache mod_proxy（也可以作为 HTTP 的正向代理） Nginx HA-Proxy Varnish Cache 三、尾言 系统设计中各功能的实现，都有相对应的基础算法，在社招面试中常伴随着一起考察。 >- 已阅留爪 (ฅ´ω`ฅ) - 下一章《一致性哈希》-","link":"/xi-tong-she-ji/systemdesign-06-proxy/"},{"title":"简单系统设计 —— 数据分区（四）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 分布式系统往往需要处理大量的数据集，如同双十一，电商需要处理上亿级别的订单量，而这些数据如果塞到一台单机数据库上，那他能否处理，以及性能有多差，可想而知。 数据分区 就是将大数据库（DB)分解为许多较小节点的技术。对于一个大规模数据集，通过分割一个DB/表的手段，让多台机器联动处理。从而提高系统的管理能力、性能、可用性以及适当的负载平衡能力。 还有一个关键因素： 当面对DB性能瓶颈时，通过添加更多的机器来水平扩容，往往比更替更强大的服务器垂直扩容来说，更便宜也更可行。 单机数据库的瓶颈： 单个表数据量越大，读写锁和插入操作重新建立索引效率越低。 单个库数据量太大（一个数据库数据量到1T-2T就是极限） 单个数据库服务器压力过大，具体指IO延迟和cpu占用率 读写速度遇到瓶颈（并发量几百） 二、分区方式 Partition Method化整为零的几个主要方式： 2.1 水平分区 Horizontal partig这种分区形式是对表的行进行分区，通过对某个属性（列）进行分割，得到多个分组，分布在不同的机器上。但整体表的特性仍然存在。这种分区的的关键问题，在于如果分区方式不合理，会导致各分区比重不均匀，导致各个节点的压力不一致。 举个例子：对于淘宝上一年的订单数据，根据每个月份可以分成12个分区。但我们知道11月份的订单数据往往最多。 2.2 垂直分区 Vertical这种分区形式是对表的列进行分区，将不同的表或者是将表的列拆成多个小表，帆布在不同的机器上。这种分区的关键问题，在于随着应用的体量的增长，需要面临进一步的分区。 举个例子： 对于用户表（头像，关注列表，昵称），拆分成个人信息表（头像，昵称），关注表（关注列表）。但随着用户体量的增加，单个服务器仍要面临瓶颈（一个服务器是不可能处理1.4亿用户的元数据查询） 2.3 基于字典的分区 Dictionary Base以上两种方式都有自己缺陷，因而在实际系统中，经常采用一种松散耦合的方式：抽象数据查找层。即在应用系统到数据元数据间，新增一层机制，单独实现元数据到DB服务器的映射关系。其目的就是能够在不影响应用程序的情况下执行DB池添加节点或者更改分区方案。 分区，狭义上指的就是将一个表的数据分成N个区块，在逻辑上仍为一张表，但底层由N个物理块组成 分表，就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。 分库，分表后数据库中的表会增加，进而需要拆分过于庞大的数据库。 将数据库比作图书馆整个分类，一张表就是一本书。当要在庞大的图书馆找到一本书显然不容易，但若将书籍分成多个类别，就可以通过类别快速找到某个书。 三、划区的依据 Partitioning Criteria本划区依据，特指水平分区。 3.1 基于键值或哈希的分区 Key or Hash该方案，就是通过一个哈希Hash函数来映射我们的实体数据的一些属性，生产对应的分区号。例如，我们由N个节点，那么可以通过ID mod N来决定存储的服务器编号。 缺陷：当我们服务器节点增加时，就会更改哈希函数的关系，这需要成功新分配数据和服务停机。但我们可以通过一致性哈希解决问题。详见后续章节。 3.2 列表分区 List该方案，就是有个列表，决定对应值的记录放在哪个服务器。例如北欧地区的国家为一个分区，亚太地区的国家为一个分区。 3.3 轮询分区 Round-robin该方案，就是雨露均沾，对于N个分区，编号为I的元数据将被分配到 ‘I mod N’的分区上。 3.4 复杂分区 Composite数据往往是复杂多样的，小孩子才做选择，实际系统中会结合以上分区方式，提供多层的分区依据。 四、分区的常见问题Common Problems相比于单点数据库，分区数据库因为实际执行服务器将是个集群，因而会有一些额外的约束条件和额外的执行复杂度： 4.1 连接表 &amp; 反规范化 连接 Join，简单来说就是连接多个表，从而查到所需要的数据。 规范化 Normalization, 就是将表尽可能地拆开，减少数据的冗余。具体可以搜索下数据库的关系范式理论。 在单点服务器中执行连接并没有什么困难，但是一旦数据库由单点转成多个节点后，跨分区的连接通常不可行或性能不高效。解决这个问题的方式就是进行适当冗余的反规范化，让操作只在单表中执行。当然这也带来了新的挑战 - 冗余数据需要保持一致。 4.2 参考完整性 Referential integrity 关系数据库，最常见的两种约束 唯一键约束 和 完整性约束。 参照完整性，简单来说就是，两个数据表是有关联的，父表中的记录必须存在，子表的记录才能存在。显然在分区数据库中强制执行数据完整性约束(比如外键)可能非常困难。 大多数RDBMS不支持跨数据库服务器上的外键约束。 当我们需要这个约束时，就需要应用程序必须在代码中强制执行参照完整性。 在这种情况下，应用程序通常必须运行常规SQL作业来清除悬空引用。 4.3 重新分配 Re-Balance尽管我们在分区方案设计的很完美，随着系统的数据规模增加，我们都需要面对重新分配分区。 按照分区规则，某个分区上的数据超过了承载量。 例如，大量国内用户注册，导致亚太区数据分区存储较大比例的数据 某个分区上存在较多的负载。 例如，随着用户体量增加，头像的请求明显增加。 面对这种情况，我们要么构建更多的数据分区，要么重新平衡各分区的数据比例。这就代表我们需要挪动数据前往新的位置，在这过程中要实现不停机是一个很大的挑战。当然，使用字典分区的方式，抽象数据查找层，能有效的实现零停机（Zero-Downtime)的效果，但也暴露了查找层存在故障的可能（单点故障）。 五 其他 Others分布式数据库是一个很庞大的技术体系，本章只是简单系统设计，重心在于入门。笔者会在后续系统学习数据库后，重新润笔。 对于分布式数据库如果很感兴趣，可以进一步看看 Google Spanner的设计论文。 Spanner 是谷歌公司研发的、可扩展的、多版本、全球分布式、同步复制数据库。它是第一个把数据分布在全球范围内的系统，而且支持外部一致性的分布式事务。 >- 已阅留爪 (ฅ´ω`ฅ) - 下一章 《索引》-","link":"/xi-tong-she-ji/systemdesign-04-data-partition/"},{"title":"简单系统设计 —— 缓存（三）","text":"本系列，是自己学习Grokking the System Design过程中的笔记。希望读者在看完全文后，也能留下你们的经验。我万分荣幸能收到你们的消息。如果能从这里学到点东西，记得请我喝杯☕☕☕~ —— MinRam 一、前言 Overview 负载均衡 帮助我们在节点不断增多的系统上进行水平扩展。而缓存 是帮我们利用现有资源，减少成本较大的逻辑处理。 缓存就是系统的短期记忆。 每一次从后端拿到的数据很有可能再次被使用，那么通过消耗一定的存储空间（内存等），当我们再次需要数据的时候，我们可以直接从存储空间获取，而不是从后端再次申请。这将节省我们很多成本。 二、在系统中的位置 Position 缓存在很多地方都可以看到，例如硬件上的CPU缓存，操作系统中内存，浏览器上的页面缓存，Web应用上的Redis等 在分布式系统中，缓存往往会使用在较前端的部分，来最大限度的降低下游的请求压力。前面提到，当我们可以直接从缓存拿到数据的时候，就不再需要往下游请求数据。 三、类型 Cache Type大多数系统主要应用几种类型的缓存： 3.1 应用服务缓存 Appliation Server Cache在请求层的应用服务器上放置缓存，同时会配置一个本地存储用于暂放请求数据。 对于服务器每次需要发送的请求时，会先检查本地存储中是否已有。如果存在，直接从本地快速获取。若不存在，再发送请求去获取索要的数据。 本地存储可以是内存（如Memcached和Redis）或者是磁盘。内存的速度显然比硬盘快几个量级 3.2 数据库缓存 Database Cache 不同于应用服务器缓存所依赖的外部缓存机制（如Redis)， 数据库自身也存在缓存。 数据库的数据分为两种： 冷数据：通常存储在磁盘上且不经常查询的数据。 热数据：频繁查询的数据，会被缓存在内存中。 通过某些级别的配置，可以针对数据库读写模型，在不更改业务代码的情况下就能提供更好的性能。而这就靠DBA或者运维工程师的功底。 笔者在数据库缓存方面并没有太多的经验，不再扩展，待后续补充。 3.3 内容分发网络 CDN 内容分发网络 Content Delivery Network = 更智能的镜像服务器 + 缓存 + 流量导控 CDN 简单来讲就是将内存缓存在离用户更近的地方。采用更多的缓存服务器（CDN边缘节点），布置在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载，将访问重定向到用户最近的缓存服务器上。由缓存服务器响应响应的请求。 CDN 将我们的应用服务器从大量的静态资源请求解放出来。对于图片，静态HTML，CSS等的资源，则从CDN节点直接获取。应用服务器将更专注于业务动态处理。 如果我们的站点还不够大，则可以通过像Nginx这样的轻量级HTTP服务器，从单独的子域(static.xxxx.com)提供简单转换。 四、缓存有效性 Invalidation 缓存减少了系统很大部分的多余请求。但是缓存终究只是真实数据（如数据库中的数据）的复制品，存在着和真实数据不一致的风险。 为解决缓存不一致性的问题，提出了缓存失效的概念： 4.1 直写缓存 Write-Through 该方案就是在写操作时，同时写入缓存和真实数据源（如数据库）。能保证快速的缓存检索，同时由于写的操作直接写入真实数据源，而具有缓存和存储保持完全的数据一致性。此外由于直接将数据推送给了真实数据源，最小化数据丢失的风险。 缺点： 写操作需要两次操作，因而存在高延迟。适用于频繁写和读的系统。 4.2 绕写缓存 Write-Around 该方案就是在写操作时，绕过缓存直接写入真实数据源。能避免缓存因为数据写入，而频繁更新。 缺点： 读操作会出现缓存丢失，因而需要重新到真实数据源检索，存在高延迟。 适用于不经常读取最近写入数据的系统。 4.3 回写缓存 Write-Back 该方案是在写操作时，只写入缓存就结束了。在一定条件(如一定的时间间隔)触发后，更新缓存到真实数据源。这对于写密集型应用程序，这将导致低延迟和高吞吐量 缺点：当节点处于故障时，将导致数据丢失。 适用于写密集行且数据不敏感的系统。 五、缓存淘汰原则 Eviction Policies 细节待更新 常见的几种缓存淘汰原则： FIFO (First In First Out) 先进先出，可以理解为一个队列。当要记录新的缓存，且缓存空间满了的时候，就淘汰缓存中存入时间最早的数据，即队列的头进尾出。 实现原理： Hash表 + 队列 LIFO (Last In First Out) 后进先出，可以理解为一个栈。当要记录新的缓存，且缓存空间满了的时候，就淘汰缓存中最新存入的数据，即栈的出栈入栈。 实现原理: Hash表 + 栈 LRU (Least Recently Used) 最近最久未使用，可以理解为一个队列，再加上刷新操作。当命中缓存时，就将缓存提出，重新压入队列。当记录新的缓存时，就淘汰最久没有用到的数据，即此时队伍的尾部。 实现原理： Hash表 + 双向链表 LFU (Least Frequently Used) 最近最少使用算法，顾名思义，就是淘汰缓存里面用的最少的数据。它根据数据的访问频次来进行淘汰数据，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。 实现原理：Hash表 + 堆 其他算法 MRU (Most Recently Used)最近最多使用，同LRU相反，淘汰的时最经常用的缓存。适用于缓存越久没被使用，那下次被使用的概率就越高的场景。 RR (Random Replacement)随机替换，佛系算法，随机替换一个缓存。 六、Redis的实际应用 待Redis系列更新… >- 已阅留爪 (ฅ´ω`ฅ) - 下一章 《数据分区》-","link":"/xi-tong-she-ji/systemdesign-03-caching/"},{"title":"简单系统设计 —— 一致性哈希（七）","text":"","link":"/xi-tong-she-ji/systemdesign-07-consistenthashing/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"系统设计","slug":"系统设计","link":"/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"负载均衡","slug":"负载均衡","link":"/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"分布式系统","slug":"分布式系统","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"知识地图","slug":"知识地图","link":"/tags/%E7%9F%A5%E8%AF%86%E5%9C%B0%E5%9B%BE/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"索引","slug":"索引","link":"/tags/%E7%B4%A2%E5%BC%95/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"分布式数据库","slug":"分布式数据库","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"哈希","slug":"哈希","link":"/tags/%E5%93%88%E5%B8%8C/"}],"categories":[{"name":"程序员面试攻略","slug":"程序员面试攻略","link":"/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%94%BB%E7%95%A5/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"系统设计","slug":"系统设计","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"瞎折腾系列","slug":"瞎折腾系列","link":"/categories/%E7%9E%8E%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97/"}]}